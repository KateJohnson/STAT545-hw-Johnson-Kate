{
    "collab_server" : "",
    "contents" : "---\ntitle: 'cm008: Notes and Exercises'\ndate: '2017-09-28'\noutput: \n    html_document:\n        toc: true\n---\n\n```{r}\nsuppressPackageStartupMessages(library(tidyverse))\nsuppressPackageStartupMessages(library(gapminder))\n```\n\nWe're ahead of schedule! As a result, I'll talk about a variety of things first, then we'll do some exercises. \n\n\n## 1. Statistical Modelling in R\n\nWe'll look at typical data analyses using R.\n\n**Note**: \n\n- You aren't expected to apply this is in your assignments! It's new to the course because we're ahead of schedule.\n- It's OK if you've never heard of these statistical analyses. The point is that many model fitting procedures in R are similar.\n\nMany statistical analyses in R follow a similar syntax.\n\n### 1.1 Linear Regression\n\n#### Model Fitting\n\nYou can run a linear regression in R with the `lm` function. Syntax:\n\n```\nlm(y ~ x1 + x2 + ... + xp, data=your_data_frame)\n```\n\nThe first argument is a \"formula\" object in R. It's typically used in modelling to separate Y and X values. (In fact, you've seen this already in `ggplot`'s  `facet_wrap` and `facet_grid`)\n\nLet's fit the regression curve that we see in this plot, using `lm`:\n\n```{r}\nggplot(gapminder, aes(gdpPercap, lifeExp)) +\n    geom_point() +\n    geom_smooth(method=\"lm\") +\n    scale_x_log10()\n```\n\nHere's the code:\n\n```{r}\nfit1 <- lm(lifeExp ~ log(gdpPercap), data=gapminder)\n```\n\nWhat does this `fit1` object look like?\n\n```{r}\nfit1\n```\n\nThat's odd... what kind of R object is that??\n\n```{r}\ntypeof(fit1)\n```\n\nIt's a list, but R isn't presenting it that way. It just looks like a bunch of text, but it's not. Let's use the `lapply` function to uncover its true nature -- a list.\n\n- NOTE: \n    - `lapply` loops over each component of a vector or list (_first argument_), applies a function to it (that you specify in the _second argument_), and outputs the function output in a list.\n    - Let's do this for an `lm` fit to `head(gapminder)`, so that the output doesn't take up a lot of space. \n\n```{r}\nfit1_small <- lm(lifeExp ~ log(gdpPercap), data=head(gapminder))\nlapply(fit1_small, identity) \n```\n\nWhy isn't R printing out the list, then? Because it's a special type of list -- it's of class `\"lm\"`, something that the makers of the `lm` function decided. Whenever R encounters this object, it also has a special way of printing it to screen. \n\nThis is the idea of the \"object oriented\" part of R -- something covered more in STAT 547 in the \"R packages\" section. \n\n#### Making predictions from the model\n\nThe `predict` function works on `\"lm\"` objects to make predictions. If you don't specify new data, it will make predictions using the existing X values. Let's look at the first six:\n\n```{r}\npredict(fit1) %>% head\n```\n\nHow about plotted against the original X values? (Which was log gdpPercap)\n\n```{r}\nqplot(log(gapminder$gdpPercap), predict(fit1))\n```\n\nFor fun... let's put this overtop of the scatterplot:\n\n```{r}\nggplot(gapminder, aes(gdpPercap, lifeExp)) +\n    geom_point(alpha=0.1) +\n    geom_point(y=predict(fit1), colour=\"red\") +\n    scale_x_log10()\n```\n\nYou can predict with new data, too, as long as the data frame you enter has the same column names as your X values. \n\n```{r}\n(my_newdata <- data.frame(gdpPercap=c(100, 547, 289)))\npredict(fit1, newdata=my_newdata)\npredict(fit1, newdata=filter(gapminder, country==\"Canada\"))\n```\n\n\n#### Extracting model characteristics\n\nWe can extract a bunch of things from the `lm` output.\n\n- Regression coefficients? They're stored in the `$coefficients` part of the list. Or, use the `coeff` function.\n\n```{r}\nfit1$coefficients\ncoef(fit1)\n```\n\n- Residuals? They're stored in the `$residuals` part of the list. Or, use the `resid` function. (Let's only display the first six... but plot all of them!)\n\n```{r}\nfit1$residuals %>% head\nresid(fit1) %>% head\nqplot(log(gapminder$gdpPercap), resid(fit1)) +\n    geom_hline(yintercept=0,\n               linetype=\"dashed\")\n```\n\n`lm` is kind of annoying in that not everything you might want is there. You can access more things using the `summary` function. What's printed to screen after `summary`, though, _is_ quite nice!\n\n```{r}\n(summ_fit1 <- summary(fit1))\n```\n\nYou can see all sorts of things, like p-values, $R^2$ (and adjusted $R^2$ values), and standard errors. \n\nAs before, this looks nice and all... but what the heck is this new object? Again, it's a list. Let's see its components (again, with the smaller fit, so that we don't take over all the space on the screen).\n\n```{r}\nsumm_fit1_small <- summary(fit1_small)\ntypeof(summ_fit1_small)\nlapply(summ_fit1_small, identity)  # Pry it open!!\n```\n\nThere we have it. Now, what would you like to extract?:\n\n- R-squared? R-squared adjusted? Okay:\n\n```{r}\nsumm_fit1$r.squared\nsumm_fit1$adj.r.squared\n```\n\n- Estimated standard devaition of the random error term? Okay:\n\n```{r}\nsumm_fit1$sigma\n```\n\nWhere can we find the documentation for the components of _this_ list, though, if it's not in the documentation for `lm`? Look at the documentation of `summary.lm`. \n\nBut wait! Why not just look at the documentation for `summary`? It's because `summary` is a generic function, and depends on the _class_ of object it's being applied to. If it's of class `\"lm\"`, then `summary.lm` is what's actually secretly run. Running `summary` on an object of class `\"glm\"`? R will secretly run `summary.glm` instead. \n\nPS: The `broom` package makes a lot of this easier and less cryptic. We won't go over it here. Check out [its vignette](https://cran.r-project.org/web/packages/broom/vignettes/broom.html).\n\n### 1.2 Generalized Linear Models (like Logistic Regression)\n\nWe won't go over this in as much detail, because it's quite similar to `lm`. But if you want to run a Generalized Linear Model (GLM) -- such as logistic/binomial regression, or Poission regression -- just use the `glm` function.\n\nProbably the biggest noteworthy difference is the `family` argument, specifying what type of regression you want to do. Syntax:\n\n```\n## Poisson regression:\nglm(y ~ x1 + x2 + ... + xp, family=poisson, data=your_data_frame)\n## Logistic (aka Binomial) regression:\nglm(y ~ x1 + x2 + ... + xp, family=binomial, data=your_data_frame)\n```\n\nIts output looks similar to `lm`. It's also a list disguised as text. It also shows more when you use the `summary` function. It also works with the `predict` function. It also becomes tidier when used in conjunction with the `broom` package.\n\n### 1.3 Others...\n\nHere are some other packages/functions you might find useful to fit models:\n\n- (Generalized) Mixed Effects Models\n    - Two R packages are available: `lme4` and `nlme`. \n        - Check out [this](http://stats.stackexchange.com/questions/5344/how-to-choose-nlme-or-lme4-r-library-for-mixed-effects-models) discussion on Cross Validated for a comparison of the two packages.\n    - I've found the function `glmer` in the `lme4` package to be fruitful.\n- Kernel smoothing (i.e. fitting a \"smoother\"): check out the `loess` function.\n- Generalized Additive Models: The `gam` function in _either_ the `gam` package or `mgcv` package.\n- Robust linear regression: The `rlm` function in the `MASS` package is your friend.\n- Regularized regression (GLM) (lasso, elastic net, or ridge regression): Use the `glmnet` function in the `glmnet` package.\n    - PS: I _highly_ recommend this if you have more predictors/covariates/features than you know what to do with... this will weed out the unnecessary ones, _and_ produce a model with good prediction accuracy at the same time.\n\n\n## 2. More `dplyr`\n\nThere's one more important thing with `dplyr` that you ought to know: applying `mutate` to a grouped tibble.\n\nRemember applying `summarize` to a grouped tibble?\n\n```{r}\ngapminder %>%\n    group_by(continent) %>% \n    summarize(mean_gdpPercap = mean(gdpPercap),\n              n_countries    = length(gdpPercap))\n```\n\nWell, we can also apply `mutate` to each group, too. For example, let's calculate the growth in population since the first year on record _for each country_:\n\n```{r}\ngapminder %>% \n    group_by(country) %>% \n    mutate(pop_growth = pop - pop[1])\n```\n\nNotice that `dplyr` has retained the original grouping -- it hasn't pealed back one level of grouping. That's because there's still more than one row for each group!\n\nHow about growth compared to `1972`?\n\n```{r}\ngapminder %>% \n    group_by(country) %>% \n    mutate(pop_growth = pop - pop[year==1972])\n```\n\nIn general, this type of \"grouped mutation\" is useful for _window functions_. What's that? Well, let's see other types of functions in R:\n\n- __Vectorized Functions__: These take a vector, and operate on each component independently to return a vector of the same length. In other words, they work element-wise. \n    - Examples are `cos`, `sin`, `log`, `exp`, `round`. \n    - We don't need to `group_by` in order to `mutate` with these. \n- __Aggregate Functions__: These take a vector, and return a vector of length 1 -- as if \"aggregating\" the values in the vector into a single value.\n    - Examples are `mean`, `sd`, `length`, `typeof`.\n    - We use these in dplyr's `summarise` function.\n- __Window Functions__: these take a vector, and return a vector of the same length _that depends on other values in the vector_. \n    - Examples are `lag`, `rank`, `cumsum`. \n    - See the [window-functions](https://cran.r-project.org/web/packages/dplyr/vignettes/window-functions.html) vignette for the `dplyr` package. \n\n## 3. More `ggplot`\n\n(Have you seen the [ggplot2 cheatsheet](https://www.rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf)? It contains __a lot__ of useful information on two pages!)\n\n### 3.1 `theme` layers\n\nYou can change the look of a plot by adding a `theme` layer to your ggplot layers. This function does __not__ actually change the \"nature\" of the plot itself -- only the look! i.e., the so-called \"non-data\" type displays. \n\nExamples:\n    - font\n    - justification of titles\n    - rotation of labels\n    - background colour\n    - line thickness\n    - etc...\n\nThere are [\"complete themes\"](http://ggplot2.tidyverse.org/reference/ggtheme.html) that come with `ggplot2`, my favourite being `theme_bw` (I've grown tired of the default gray background, so `theme_bw` is refreshing).\n\nLet's see an example:\n\n```{r}\np1 <- ggplot(gapminder, aes(gdpPercap, lifeExp)) +\n    facet_wrap(~ continent) +\n    geom_point(colour=\"#386CB0\", alpha=0.2) +\n    scale_x_log10()\np1 + theme_bw()\n```\n\nThe general `theme` function gives you vast functionality... just check its documentation to see what things you can change. The arguments of `theme` follow a naming convention: `general.to.specific`\n\nFor example,\n    - `axis.title` will allow you to change the font of the axis titles.\n    - `axis.title.x` does the same, but focusses on the `x` axis.\n\n__Note__: You _can't_ change the actual words this way! That's changing the nature of the plot, and not the _look_ of the plot. \n\nOnce we've chosen an argument name, we need to specify its value. This is almost always the output of one of the following functions:\n\n- `element_blank` (basically means replace with \"nothing\")\n- `element_rect`: allows us to specify features of a _rectangle_.\n- `element_line`: allows us to specify features of a _line_.\n- `element_text`: allows us to specify font. \n\nCheck out their documentation to see exactly how each feature is modified.\n\n- __Example__: To `p1` above, do all of the following....\n    - change the background strip colour to orange, \n    - change the axis titles' font sizes to 14, and \n    - change the panel titles' font sizes to 14 and bolded.\n\n```{r}\np1 +\n    theme(strip.background = element_rect(fill=\"orange\"),\n          axis.title = element_text(size=14),\n          strip.text = element_text(size=14, face=\"bold\"))\n```\n\n__Another example__: do the same, but in conjunction with the `theme_bw` (notice the order)\n\n```{r}\n## Correct:\np1 +\n    theme_bw() +\n    theme(strip.background = element_rect(fill=\"orange\"),\n          axis.title = element_text(size=14),\n          strip.text = element_text(size=14, face=\"bold\"))\n## Incorrect:\np1 +\n    theme(strip.background = element_rect(fill=\"orange\"),\n          axis.title = element_text(size=14),\n          strip.text = element_text(size=14, face=\"bold\")) +\n    theme_bw()  # Overrides the previous `theme` call!\n```\n\n\n### 3.2 Modifying scales\n\nRecall that we use some _scale_ to represent the _range of values that a variable takes_ in our data. `ggplot` chooses defaults for this scale, but we can change those.\n\nCheck out [this tutorial by Hadley Wickham](https://github.com/hadley/ggplot2-book/blob/master/scales.rmd) for scales. \n\nWe can modify scales using a suite of functions that have the following naming convention: `scale_a_b`, where:\n\n- `a` is the scale you want to change. Is it `colour`? `size`? `x` position?\n- `b` typically speaks to the nature of the variable. `continuous` is your variable is continuous; `discrete` if discrete. But, could be other things in certain cases, like `log10`, or `date` if your variable consists of dates. `manual` is an option too.\n\n__Examples__: `scale_x_continuous`, `scale_colour_discrete`, `scale_y_sqrt`.\n\nAs usual in ggplot, these functions are added as a layer. \n\n#### Useful arguments\n\nThere are many useful arguments here. Some are more self-explanatory than others. \n\n- `name`. The first argument. Indicate the name of the scale/legend here.\n    - You can also use the `labs` function for X and Y axes, and even plot title.\n\n```{r}\np1 + scale_y_continuous(\"Life Expectancy\")\np1 + labs(x=\"GDP per capita\", \n          y=\"Life Expectancy\",\n          title=\"My Plot\")\n\nggplot(gapminder, aes(gdpPercap, lifeExp)) +\n    geom_point(aes(colour=continent),\n               alpha=0.2) +\n    scale_colour_discrete(\"Continents of\\n the World\")\n```\n\n- `breaks` (Typically of a continuous scale). Here, you get to specify _where_ along the scale you'd like to display a value. \n    - Numbers are on the scale of the data (such as population), not the geometric scale (such as a hex colour code, or number of pixels over in a plot). \n\n```{r}\n## Log lines:\np1 + scale_x_log10(breaks=c((1:10)*1000,\n                            (1:10)*10000))\n\np2 <- ggplot(gapminder, aes(gdpPercap, lifeExp)) +\n    geom_point(aes(colour=pop/10^9),\n               alpha=0.2)\n## Default breaks\np2 + scale_colour_continuous(\"Population\\nin billions\")\n## New breaks\np2 + scale_colour_continuous(\"Population\\nin billions\",\n                             breaks=seq(0,2,by=0.2))\n```\n\n- `labels`. Text to replace the data value labels. Most useful for discrete data.\n\n```{r}\n## Not a good idea:\np2 + scale_colour_continuous(\"My odd\\npopulation\\nscale\",\n                             breaks=c(0.2, 0.7, 1.2),\n                             labels=c(\"small\", \"bigger\", \"big\"))\n\n## Discrete scale:\nggplot(gapminder, aes(gdpPercap, lifeExp)) +\n    geom_point(aes(colour=continent),\n               alpha=0.2) +\n    scale_colour_discrete(labels=c(\"Af\", \"Am\", \"As\", \"Eu\", \"Oc\"))\n```\n\n- `limits`. Lower and upper bounds of the data that you'd like displayed. Leave one as `NA` if you want to use the default.\n\n```{r}\np1 + scale_y_continuous(limits=c(60,NA))\n```\n\n- `position`. Position of the scale. Also controllable using `theme` for the legend.\n\n```{r}\np1 + scale_y_continuous(position=\"right\")\np2 + theme(legend.position = \"bottom\")\n```\n\n## 4. Exercises. \n\nPractice these concepts in the following exercises.\n\n__Exercise 1__: Suppose we want to calculate some quantity for each country in the `gapminder` data set. For each of the following quantities, indicate whether the function is _vectorized_, _aggregate_, or _window_, and use `dplyr` functions to calculate the specified variable.\n\n- The change in population from 1962 to 1972.\n- The population, in billions.\n```{r}\n# It's a vectorized function\ngapminder %>%\n  mutate(pop_in_bill = pop/10^9)\n```\n\n- The lagged gdpPercap\n    - i.e., the value that appears for 1962 would be the gdpPercap in 1957 (the previous entry).\n    - Hint: use the `lag` function, then filter out the `NA`'s created with the `is.na` function.\n```{r}\n# It's a window function\ngapminder %>%\n  group_by(country) %>%\n    arange(year) %>%\n      mutate(lg_gdp=lag(gdpPercap)) %>%\n        filter(!is.na(lg_gdp))\n```\n\n\n__Exercise 2__: For the `gapminder` dataset, make a spaghetti plot showing the population trend (in millions) over time for each country, facetted by continent. Make as many of the following modifications as you can:\n\n- Colour each line by the log maximum gdpPercap experienced by the country.\n- Rotate the x-axis labels to be vertical.\n- Remove the x-axis title.\n- Give the legend an appropriate title.\n- Put the y-axis on a log-scale. \n- Rename the y-axis title.\n- Add more numbers along the y-axis.\n- Give the plot a title, and center the title. \n- Only label the x axis with years 1950, 1975, and 2000.\n- Move the colour scale to the bottom.\n- Rename the colour legend\n",
    "created" : 1507048510999.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2707834580",
    "id" : "C7185683",
    "lastKnownWriteTime" : 1507049923,
    "last_content_update" : 1507049923195,
    "path" : "~/Google Drive/Classes/STAT 545.547/cm008-notes_and_exercises.Rmd",
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}